### 2.5 控制流指令
+ RV32I 提供两种控制流指令：无条件跳转指令和条件分支指令。RV32I 的控制流指令并没有结构上可见的延迟槽。

#### 无条件跳转
+ UJ 格式的 JAL 指令运用到 J 格式的立即数编码方式，先左移一位之后进行符号位扩展。符号位扩展之后的立即数加上 pc 值作为跳转目标地址，因此可以控制指令跳转到当前位置前后 1 MiB 的范围内。JAL 指令将（pc + 4）存放在目的寄存器 rd 中。标准的软件中系统调用约定用寄存器 x1 作为返回地址寄存器。
+ 当 JAL 的 rd = x0 的时候，即为简单的 jump 指令（汇编程序中的微指令 J）。
![jal_format][1]
+ 用 I 格式编码的间接跳转指令 JALR（jump and link register），由寄存器 rs1 中的操作数加上 12 比特位的 I 格式的有符号立即数，然后把最小有效位设置为 0 来产生分支目标地址。把 jump 指令的下一地址（pc + 4）写入寄存器 rd。在不需要保存这个地址的时候，我们可以把目的寄存器设置为 x0。
![jalr_format][2]

###### 在这一段里，我们看到源寄存器的基址和 12 比特位的偏移量直接相加，为什么不把偏移量左移 2 位来扩大跳转范围呢？为什么只把最低有效位置 0，riscv 的指令存储不应该是按字对齐的么？

------------------------------------------------------

######所有的无条件跳转指令用 pc 相对寻址来位位置无关指令提供支持，JALR 指令可以是使一个 2 条指令的指令序列实现在 32 比特位绝对地址空间范围内的任意位置的跳转。一个 LUI 指令可以先把目标地址的高 20 位放到 rs1 中，然后由 JALR 指令将它与低 20 位相加。同样的，AUIPC 后接 JALR 指令也可以实现 32 比特位 pc 相对寻址范围的任意地址跳转。
	
[1]: /riscv/image/jal_format.png
[2]: /riscv/image/jalr_format.png
